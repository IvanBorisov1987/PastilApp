Эфир делится на следующие единицы: wei, finney, szabo. Сам эфир представлен в Solidity как ether. Если единица не указана, то считается, что она измеряется в wei. Пример использования: 2 ether == 2000 finney (это выражение вернет true).

В Solidity представлены следующие единицы измерения времени: seconds, minutes, hours, days, weeks и years. Записывается следующим образом:

1 == 1 seconds
1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours
1 weeks == 7 days
1 years == 365 days
Нужно помнить, что не в каждом году 365 дней и не в каждом дне 24 часа из-за секунд координации.

Данные суффиксы не могут применяться к переменным. С переменными их нужно использовать следующим образом:

function f(uint start, uint daysAfter) public {
    if (now >= start + daysAfter * 1 days) {
      // ...
    }
}


Особые переменные и функции

Особые переменные и функции всегда находятся в глобальной области видимости и в основном используются для предоставления информации о блокчейн.

Свойства блока и транзакции

block.blockhash(uint blockNumber) returns (bytes32): хэш передаваемого блока — работает только для последних 256 блоков, исключая текущий
block.coinbase (address): текущий адрес блока майнера
block.difficulty (uint): текущая сложность блока
block.gaslimit (uint): текущий лимит газа блока
block.number (uint): текущий номер блока
block.timestamp (uint): текущая отметка времени блока в секундах начиная с “эры Unix”
msg.data (bytes): полный calldata
msg.gas (uint): оставшийся газ
msg.sender (address): отправитель текущего вызова
msg.sig (bytes4): первые четыре байта calldata
msg.value (uint): число wei, отправленных с message
now (uint): текущая отметка времени блока (псевдоним для block.timestamp)
tx.gasprice (uint): цена газа транзакции
tx.origin (address): отправитель транзакции
Примечание

Значения всех членов msg, включая msg.sender и msg.value, могут меняться для каждого внешнего вызова функции. Сюда входят вызовы функций библиотеки.

Примечание
Не стоит полагаться на block.timestamp, now и block.blockhash. Как временная метка, так и блок-хэш могут в некоторой степени быть подвержены влиянию майнеров. Текущая временная метка блока должна быть строго больше, чем метка времени последнего блока, но единственная гарантия заключается в том, что он будет находиться где-то между отметками времени двух последовательных блоков в канонической цепочке.

Примечание
Хэши блоков недоступны для всех блоков по причинам масштабируемости. Можно получить доступ к хэшам только последних 256 блоков, все остальные значения будут равны нулю.

Обработка ошибок

assert(bool condition): выбрасывает исключение, если условие не выполняется — используется для внутренних ошибок.
require(bool condition): выбрасывает исключение, если условие не выполняется — используется для ошибок во входных данных или внешних компонентах.
revert(): прекращает выполнение и возвращает изменения состояния

Математические и криптографические функции
addmod(uint x, uint y, uint k) returns (uint): вычисляет (x + y) % k, где сложение выполняется с произвольной точностью и не обертывается при 2**256.
mulmod(uint x, uint y, uint k) returns (uint): вычисляет (x * y) % k, где умножение выполняется с произвольной точностью и не обертывается при 2**256
keccak256(…) returns (bytes32): вычисляет хэш Ethereum-SHA-3 (Keccak-256) аргументов (плотно упакованных)
sha256(…) returns (bytes32): вычисляет хэш SHA-256 аргументов (плотно упакованных)
sha3(…) returns (bytes32): псевдоним для keccak256
ripemd160(…) returns (bytes20): вычисляет хэш RIPEMD-160 аргументов (плотно упакованных)
ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): восстанавливает адрес, связанный с открытым ключом из подписи эллиптической кривой или возвращает ноль при ошибке

Выше, “Плотно упакован” означает, что аргументы объединяются без отступов. Например, в следующем примере все строки идентичны:

keccak256("ab", "c")
keccak256("abc")
keccak256(0x616263)
keccak256(6382179)
keccak256(97, 98, 99)
Если отступ нужен, можно использовать явное преобразование типа: keccak256(“\x00\x12”) это то же самое, что keccak256(uint16(0x12)).

Константы будут упакованы с использованием минимального количества байтов, необходимых для их хранения. Это означает, что, например, keccak256(0) == keccak256(uint8(0)) и keccak256(0x12345678) == keccak256(uint32(0x12345678)).

Возможен Out-of-Gas для sha256, ripemd160 или ecrecover при локальной разработке. Причина в том, что они реализуются как так называемые предварительно скомпилированные контракты, и такие контракты действительно существуют только после, того как они получают первый message. Message к несуществующим контрактам дороже, и это приводит к ошибке Out-of-Gas. Обходное решение проблемы — отправить, например, 1 Wei на каждый контракт, прежде, чем использовать их в реальных контрактах. Такой проблемы нет в основной или тестовой сети.

Члены адреса
<address>.balance (uint256): баланс адреса в единице Wei
<address>.transfer(uint256 amount): отправляет указанную сумму Wei на адрес (при ошибке выбрасывает исключение)
<address>.send(uint256 amount) returns (bool): отправляет указанную сумму Wei на адрес (при ошибке возвращает false)
<address>.call(…) returns (bool): выпускает низкоуровневый CALL (при ошибке возвращает false)
<address>.callcode(…) returns (bool): выпускает низкоуровневый CALLCODE (при ошибке возвращает false)
<address>.delegatecall(…) returns (bool): выпускает низкоуровневый DELEGATECALL (при ошибке возвращает false)

Предупреждение
Существует несколько важных моментов при использовании send: передача терпит неудачу, если глубина стека вызовов достигает 1024. Также, передача не удастся, если у получателя закончится газ. Поэтому для того, чтобы защитить передачу эфира, нужно всегда проверять возвращаемое значение функции send, использовать transfer или еще лучше — использовать шаблон, в котором получатель забирает деньги.

Примечание
Использовать callcode не рекомендуется, и эта функция будет удалена в будущем.

Связанные с контрактом
this (тип текущего контракта): текущий контракт, явно преобразуемый в Адрес

selfdestruct(address recipient): уничтожает текущий контракт, отправляя его средства на указанный Адрес
suicide(address recipient): псевдоним для selfdestruct
Кроме того, все функции текущего контракта вызываются напрямую, включая текущую функцию.
